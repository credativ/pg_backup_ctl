#!/bin/bash

# Copyright (c) 2007 Peter Eisentraut <peter.eisentraut@credativ.de>
# Copyright (c) 2007-2012 Bernd Helmle <bernd.helmle@credativ.de>
# Copyright (c) 2011-2012 Arnd Hannemann <arnd.hannemann@credativ.de>
# Copyright (c) 2012-2013 Christoph Berg <christoph.berg@credativ.de>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE

##
## pg_backup_ctl - PostgreSQL transaction log archival backup control program
##
## Version: @@VERSION@@

set -e
umask 077
# This is required so that sorted directory listings are consistent.
export LC_COLLATE=C

me=$(basename $0)
hdrline=$(printf "%080d"|tr "0" "-")

PG_BACKUP_LOCK_TIMEOUT=60

help="\
PostgreSQL transaction log archival backup control program
Supports PostgreSQL 8.3 and above

Usage: $me -A ARCHIVEDIR [OPTION...] MODE

Modes:
  setup          prepare server for transaction log archival
  basebackup     perform a base backup
  lvmbasebackup  perform a base backup using LVM snapshot
                 (requires -L -M -n -N)
  create-lvmsnapshot
                 create an LVM snapshot for an external backup command
                 (requires -L -M -n -N)
  remove-lvmsnapshot
                 remove an LVM snapshot created with create-lvmsnapshot
  restore BASEBACKUP
                 Restores the specified basebackup into the specified
                 directory by the -D parameter. 
                 The directory must already exist and be empty.
                 The destination directory will also contain a generated
                 recovery.conf, suitable to start a PostgreSQL instance for
                 recovery immediately.
  currentbackup  backup the current WAL file (run from cron job)
  cleanup [ FILENAME | XLOG | +[1-9]* ]
                 remove old WAL files after new base backup (run from cron job)

                 It is possible to specify the base backup filename FILENAME,
                 which WAL files should be kept at least or the WAL file XLOG.
                 If a positiv number greater than zero is specified, the cleanup
                 command will treat it as its retention policy and keep at
                 least this number of base backup files. Please note that the
                 latter form of the cleanup command will delete all outdated
                 base backups as well whereas the two forms of cleanup invoked
                 with filenames will delete the WAL files only.

                 If no argument is specified, cleanup will remove all WAL
                 files except those which are required by the latest base
                 backup.
  ls[+]          Lists available base backups and their size in the current archive.
                 When issued with +, the ls command will examine the WAL archive
                 and the minimum WAL segment file, required to use the backup
                 to perform a full recovery.

Options:
  -A ARCHIVEDIR archival target directory (required)
  -D DATADIR    database system directory (recommended)
  -m            archive old log files before deleting them
  -z            use gzip to compress archived WAL segments
LVM snapshot control:
  -L LVM SIZE   determines the buffer size for an LVM snapshot
  -M VOLUME     LVM volume identifier to create the snapshot on
  -n SNAPSHOT   LVM snapshot volume name
  -N LVMDATADIR PostgreSQL DATADIR relative to partition (i.e. the path
                to DATADIR inside the LVM snapshot)
  -o MOUNTOPTS  additional options passed to LVM snapshot mount
Server connection control:
  -h HOSTNAME   server host name
  -p PORT       server port
  -U USERNAME   server user name
"

if [ "${1:---help}" = "--help" ]; then
    echo "$help"
    exit 0
fi

set -- $(getopt A:D:h:L:M:mn:N:o:p:U:z "$@")

while :; do
    case $1 in
        -A) archivedir=$2; shift;;
        -D) datadir=$2; shift;;
        -h) export PGHOST=$2; shift;;
	-L) lvm_size=$2; shift;;
	-n) lvm_snap_name=$2; shift;;
	-M) lvm_vol=$2; shift;;
        -m) cleanup_move=yes;;
	-n) lvm_snap_name=$2; shift;;
	-N) lvmdatadir=$2; shift;;
        -o) mountopts=$2; shift;;
        -p) export PGPORT=$2; shift;;
        -U) export PGUSER=$2; shift;;
        -z) gzip=yes;;
        --) shift; break;;
    esac
    shift
done

export PGDATABASE=postgres

mode=$1; shift || :


error() {
    echo "$me:" "$@" 1>&2
    exit 1
}


current_setting() {
    psql -tA -c "SELECT current_setting('$1');"
}

timestamp() {
    # A detailed timestamp is good to uniquely identify a backup.
    date +'%Y-%m-%dT%H%M'
}

check_rsync_dep() {
	# check if needed programs are there
	if ! command -v rsync >/dev/null; then
		error "cannot find rsync command"
	fi;
}

##
## Returns the PostgreSQL major version of the specified PGDATA directory
## as an integer. That is, the first two digits are concatenated to a unified
## number so it can be compared arithmetically (e.g. 9.0.4 will be returned
## as 90).
##
## Caller should make sure PGDATA really exists
##
get_pg_major_version() {

    local PGMAJOR=$(cat "$datadir"/PG_VERSION | awk -F'.' '{print $1$2;}')
    echo $PGMAJOR

}

## Checks the specified archive directory (-A)
check_archivedir() {

    if [ -z "$archivedir" ]; then
        error "no archive directory specified"
    fi

    local x

    for x in "$archivedir"/{base,log,current,lvm_snapshot}; do
        if [ ! -d "$x" ]; then
            mkdir -p "$x"
        fi
    done

    ## Force LOCK file to be in $archivedir. This fixes an issue on
    ## some Linux systems, where /var/lock/ isn't writeable by daemons.
    ## $archivedir must be writable by the postgres user anyway, so we
    ## assume we can use it for the lock file, too.
    LOCK="$archivedir/pg_backup_ctl.base.lock"

}

## Checks the specified data directory (-D, if present) or
## gets the setting from a possible running PostgreSQL instance.
check_datadir() {

    # Especially when calling currentbackup, specifying a data directory
    # directly is advisable to avoid frequent database connections.
    if [ -z "$datadir" ]; then
        datadir="$(current_setting data_directory)"
    fi

    if [ ! -r "$datadir"/PG_VERSION ]; then
        error "cannot read data directory (permissions?)"
    fi

}

check_lvm_params() {

	## check LVM parameters

	if [ -z "$lvm_size" ]; then
		error "no LVM snapshot size (-L) specified"
	fi

	## specified volume exists?
	if [ -z "$lvm_vol" ]; then
		error "no LVM volume (-M) specified"
        else
                if ! sudo /sbin/lvdisplay $lvm_vol > /dev/null 2>&1; then
                    error "logical volume \"$lvm_vol\" not found"
                else
		    local RC=$(sudo /sbin/lvdisplay -c $lvm_vol | awk -F ':' '{print $4;}')
		    if [ "$RC" -ne 1 ]; then
                        error "\"$lvm_vol\" is not a valid LVM volume"
                    fi
                fi
	fi

	if [ -z "$lvm_snap_name" ]; then
		error "no LVM backup name (-n) specified"
	fi

	if [ -z "$lvmdatadir" ]; then
		error "LVM snapshots requires the datadir relative to $archivedir/lvm_snapshot (-N)"
	fi

        if [ ! -z "$mountopts" ]; then
            mountopts="-o $mountopts"
        fi
}

do_setup() {

    if [ $(ls "$datadir"/pg_tblspc | wc -l) -gt 0 ]; then
        error "clusters uses tablespaces, this is not supported by $me"
    fi

    local cmd
    if [ "$gzip" = yes ]; then
        cmd="test ! -f \\\\'$archivedir/log/%f.gz\\\\' && gzip -c \\\\'%p\\\\' > \\\\'$archivedir/log/%f.gz\\\\'"
    else
        cmd="test ! -f \\\\'$archivedir/log/%f\\\\' && cp \\\\'%p\\\\' \\\\'$archivedir/log/%f\\\\'"
    fi
    local cf=$(current_setting config_file)

    if grep -q archive_command "$cf"; then
        sed -i -e "/archive_command/ c archive_command = '$cmd'" "$cf"
    else
        (echo; echo "# automatically added by $me"; echo "archive_command = '$cmd'") >>$cf
        echo "Added archive_command to postgresql.conf"
    fi

    ## Activate archiving. This requires a server restart if not yet set. Hint the
    ## user, if we changed anything here.
    local archivemode=$(current_setting archive_mode)

    if grep -q archive_mode "$cf"; then
        if [ ! -z "$archivemode" ] && [ "$archivemode" = "off" ]; then
            sed -i -e '/archive_mode/ c archive_mode = on' "$cf"
            echo "HINT: activated archive_mode, you need to restart the server to get archiving activated"
        else
            echo "HINT: archive_mode already activated, adjusted archive_command only"
        fi
    else
        (echo; echo "# automatically added by $me"; echo "archive_mode = on") >>$cf
        echo "Added archive_mode to postgresql.conf"
    fi

    local pg_major_version=$(get_pg_major_version)

    ## Starting with PostgreSQL 9.0, we define different wal levels to adjust the traffic into
    ## the transaction log. For archiving, we need at least wal_level = archive to be set, otherwise
    ## PostgreSQL will refuse to start.

    if [ $pg_major_version -ge 90 ]; then
        local wallevel=$(current_setting wal_level)

        if grep -q wal_level "$cf"; then
            if [ ! -z "$wallevel" ] && [ "$wallevel" != "archive" ] && [ "$wallevel" != "hot_standby" ]; then
                sed -i -e '/wal_level/ c wal_level = archive' "$cf"
                echo "HINT: set wal_level to 'archive', you need to restart the server to get this setting into effect"
            else
                echo "HINT: wal_level already set to 'archive'"
            fi
        else
            (echo; echo "# automatically added by $me"; echo "wal_level = archive") >>$cf
            echo "Added wal_level to postgresql.conf"
        fi
    fi

    kill -HUP $(head -1 "$datadir/postmaster.pid")

    # warn if rsync is missing
    if [ $pg_major_version -lt 90 ]; then
        if ! command -v rsync >/dev/null; then
            echo "HINT: rsync is not installed. For PostgreSQL version $pg_major_version, you should use the "currentbackup" functionality of pg_backup_ctl which needs rsync"
        fi
    fi
}


do_currentbackup() {

    local files x y

    # identify unarchived files
    for x in $(ls -r "$datadir"/pg_xlog/ | egrep '^[0-9A-F]{24}$'); do
        if [ ! -f "$datadir"/pg_xlog/archive_status/$x.done ]; then
            files="$files $x"
        fi
    done

    # copy unarchived files
    (cd "$datadir"/pg_xlog/ && rsync $files "$archivedir"/current/)

    # remove previously copied files that are now archived
    for x in $(cd "$archivedir"/current && ls); do
        for y in $files; do
            [ $x = $y ] && break 2
        done
        rm "$archivedir"/current/$x
    done
}


do_basebackup() {

    local status=0
    local ts="$(timestamp)"
    local tmpfn="$archivedir/base/.basebackup_$ts.tar.gz.in-progress"
    local fn="$archivedir/base/basebackup_$ts.tar.gz"
    trap "rm -f $tmpfn" 0 2 3 15 # clean up on error

    psql -c "SELECT pg_start_backup('$fn');" >/dev/null
    tar --force-local -C "$datadir" -c -z -f "$tmpfn" --exclude=postmaster.pid --exclude=pg_xlog . || status=$?
    psql -c "SELECT pg_stop_backup();" >/dev/null

    if [ $status -eq 0 ] || [ $status -eq 1 ]; then # exit 1 is "some files changed"
	mv "$tmpfn" "$fn"
	return 0
    else
	rm -f "$tmpfn"
	return $status
    fi
}

##
## Recover the specified basebackup into the specified
## data directory.
##
do_restore_basebackup() {

    local status=0
    local fn="$archivedir/base/$1"
    local dn="$datadir"

    # sanity checks first
    if [ -z "$dn" ]; then
	error "The restore command requires the -D command line argument"
    fi

    # check if requested basebackup exists
    if [ ! -f "$fn" ]; then
	error "requested basebackup \"$fn\" does not exist"
    fi

    # File found, proceed. Check if the specified
    # recovery target directory exists.
    if [ ! -d "$dn" ]; then
	error "target directory does not exist"
    fi

    # Target directory empty?
    if [ "$(find "$dn" -type f | wc -l)" -gt 2 ]; then
	## does it contain a running PostgreSQL instance?
	if [ -e "$dn"/PG_VERSION ]; then
	    local ver=$(get_pg_major_version)
	    error "target directory contains a PostgreSQL database cluster \"$ver\""
	else
	    error "target directory not empty"
	fi
    fi

    # Make sure, target directory has 0700 permissions
    chmod 0700 $dn

    # Unpack TAR archive into destination directory
    tar --force-local -C "$dn" -x -z -f "$fn" && echo "successfully restored \"$fn\""

    # create pg_xlog/archive_status directory (newer PostgreSQL
    # releases will do this automatically, but it doesn't no harm
    # if done here...
    mkdir -p "$dn"/pg_xlog/archive_status

    ## place the recovery.conf
    _gen_recovery_conf "$dn"

    [ $status -eq 0 ] || [ $status -eq 1 ]

}

##
## Generates a recovery.conf file and places
## it withtin the specified target directory
##
## Caller is responsible to place a valid
## target directory within $1...
##
_gen_recovery_conf() {

    local dn="$1"
    local cmd=""

    if [ "$gzip" = yes ]; then
        cmd="gzip -d -c \\'$archivedir/log/%f.gz\\' > \\'%p\\'"
    else
        cmd="cp \\'$archivedir/log/%f\\'  \\'%p\\'"
    fi

    echo "restore_command='$cmd'" > "$dn"/recovery.conf

}

##
## Create an LVM snapshot, pass $2 as a backup label
## to pg_start_backup() if required, overriding the default
## label "LVM SNAPSHOT YYYY-MM-DDTHHMM"
##
_create_snapshot_LVM() {

    local status=0
    local fn="$1"
    local label

    if [ ! -z "$2" ]; then
        label="$fn"
    else
        ##
        ## XXX: We obtain a separate timestamp for labeling the LVM snapshot.
        ##      Do this only in case no backup_label was specified (which,
        ##      effectively would have generated the label and basebackup
        ##      filename already).
        ##
        label="LVM SNAPSHOT $(timestamp)"
    fi

    psql -c "SELECT pg_start_backup('$label');" >/dev/null
    sudo lvcreate -s -n "$lvm_snap_name" -L "$lvm_size" "$lvm_vol" || status=$?

    psql -c "SELECT pg_stop_backup();" >/dev/null
    [ $status -ne 0 ] && echo "LVM snapshot failed with status $status" && return $status

    ## mount the snapshot in the archive directory LVM snaphost mountpoint
    local LVMSNAPSHOTMNT="$(dirname $lvm_vol)/$lvm_snap_name"
    sudo /bin/mount $mountopts $LVMSNAPSHOTMNT "$archivedir"/lvm_snapshot || error "could not mount snapshot in $archivedir/lvm_snapshot"

}

##
## Remove an LVM snapshot previously created with _create_snapshot_LVM
##
_remove_snapshot_LVM() {

    local status=0
    local LVMSNAPSHOTMNT="$(dirname $lvm_vol)/$lvm_snap_name"

    ## unmount the snapshot
    sudo /bin/umount "$archivedir"/lvm_snapshot
    echo "removing LVM snapshot $LVMSNAPSHOTMNT"
    sudo /sbin/lvremove -f -t $LVMSNAPSHOTMNT > /dev/null 2>&1 && sudo /sbin/lvremove -f $LVMSNAPSHOTMNT 1> /dev/null || status=$?

    return $status
}

##
## Create an LVM snapshot and perform a basebackup via tar.
##
## This calls _create_snapshot_LVM() internally, which does
## the legwork of creating the necessary LVM snapshot and
## prepares the mount.
##
## Please note that do_create-lvmsnapshot never performs a real basebackup,
## instead it creates an archive file with just the backup_label included. It
## is up to an external backup software to do the actual base backup.
##
do_create-lvmsnapshot() {
    check_lvm_params

    local status=0
    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz

    ## do the backup, fall through all errors!
    if _create_snapshot_LVM "$fn"; then
        tar --force-local -C "$archivedir/lvm_snapshot/$lvmdatadir/" -c -z -f "$fn" ./backup_label || status=$?
    fi

    [ $status -eq 0 ] || [ $status -eq 1 ]
}

##
## Remove an LVM snapshot previously created via _create_snapshot_LVM().
##
do_remove-lvmsnapshot() {
    local status=0

    _remove_snapshot_LVM || status=$?

    [ $status -eq 0 ] || [ $status -eq 1 ]
}

##
## Creates a full basebackup from an LVM snapshot.
##
do_lvmbasebackup() {
    check_lvm_params

    local status=0

    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz
    _create_snapshot_LVM "$fn" "$fn"

    ## do the backup, fall through all errors!
    tar --force-local -C "$archivedir/lvm_snapshot/$lvmdatadir" -c -z -f "$fn" --exclude=postmaster.pid --exclude=pg_xlog . || status=$?

    ## unmount the snapshot
    _remove_snapshot_LVM || status=$?

    [ $status -eq 0 ] || [ $status -eq 1 ]
}

start_wal_location() {
    sed -n -r '/^START WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


stop_wal_location() {
    sed -n -r '/^STOP WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


do_cleanup() {
    local first_wal last_wal x

    local fn=$(basename "$1")
    case $fn in
        basebackup_*.tar*)
            first_wal=$(gunzip -c -f "$1" | tar -f - -x -O ./backup_label | start_wal_location)
            ;;
        [0-9A-F]*[0-9A-F].[0-9A-F]*[0-9A-F].backup*)
            first_wal=$(gunzip -c -f "$1" | start_wal_location)
            last_wal=$(gunzip -c -f "$1" | stop_wal_location)
            if [ ! -f "$archivedir"/log/$last_wal* ]; then
                error "base backup \"$1\" is not complete; log segment \"$last_wal\" is not archived yet"
            fi
            ;;
        '')
            local last_backup
            for x in $(ls -r "$archivedir"/log/*.backup* | head -1); do
                last_wal=$(gunzip -c -f "$x" | stop_wal_location)
                if [ -f "$archivedir"/log/$last_wal ] || [ -f "$archivedir"/log/$last_wal.gz ] ; then
                    last_backup=$x
                    break
                fi
            done
            if [ -z "$last_backup" ]; then
                error "no complete backup found"
            fi
            first_wal=$(gunzip -c -f "$last_backup" | start_wal_location)
            ;;
	+[1-9]*)
	    local retention_policy=$1
	    local base_backups=$(ls -tr "$archivedir"/base/basebackup_*.tar*)
	    local num_backups=$(echo "$base_backups" | wc -l)

	    if [ $num_backups -le $retention_policy ]; then
		echo "no base backups to delete found"
		return 1
	    else
		local candidates
		local newest_candidate

		candidates=$(echo "$base_backups" | head -n $(($num_backups - $retention_policy)))
		oldest_keep=$(echo "$base_backups" | head -n $(($num_backups - $retention_policy + 1)) | tail -n1)
		newest_candidate=$(echo "$candidates" | tail -n1)

		## This recurses into cleanup and removes all WAL files
		## belonging to the list of candidates. Those aren't required
		## anymore, since we are going to delete base backup candidates
		## afterwards.
		## NOTE:
		##
		## We need to specify the oldest base backup to *keep*, since
		## do_cleanup() will keep all WAL files belonging to the specified
		## base backup.
                ##
                ## XXX: Currently we are performing the cleanup based on selecting
                ##      the base backup files from $archivedir/base. In the
                ##      future, we might change this code to select the base
                ##      backups according to the backup history files found there.
		do_cleanup $oldest_keep

		for i in $candidates; do
		    rm "$i"
		done
	    fi

	    ## exit immediately after cleaning base backups. We *must* return
	    ## to the caller, otherwise do_cleanup() will proceed and delete all WAL
	    ## files older than the current base backup.
	    return 0
	    ;;
        *)
            error "invalid cleanup target specification"
            ;;
    esac

    if [ -f "$archivedir"/log/$first_wal ] || [ -f "$archivedir"/log/$first_wal.gz ]; then
        local old_files=$(ls "$archivedir"/log | sed -n "/$first_wal/q;p")
        (
        cd "$archivedir"/log
        if [ "$cleanup_move" = yes ]; then
            tar --force-local -c -z -f "$archivedir"/base/oldwals-$(timestamp).tar.gz $old_files
        fi
        rm -f $old_files
        )
    fi
}

backup_label() {
    sed -n -e '/^LABEL:/s/^LABEL://;s/^\s//p'
}

do_ls() {

    local backups basesize wallogsize walcount

    backups=$(ls -t $archivedir/log/[0-9A-F]*[0-9A-F].[0-9A-F]*[0-9A-F].backup* 2> /dev/null || return 0)

    if [ -z "$1" ]; then
        printf "%-71s\t%-9s\n" "Basebackup Filename" "Size"
    else
        printf "%-53s\t%s\t%-24s\t%-3s\n" "Basebackup Filename" "Size" "Required WAL" "Available"
    fi

    echo $hdrline

    for x in $backups; do

        local fn=$(basename "$(cat "$x" | gunzip -f -c | backup_label)")

        case $fn in

            basebackup_*.tar.gz)
                fn="$(basename $fn)"
                basesize=$(du -sh "$archivedir/base/$fn" | awk '{print $1;}')
                ;;
            *SNAPSHOT*)
                basesize=0
                ;;
            *)
                echo "$x: Label \"$fn\" is not an expected basebackup filename"
                continue
                ;;

        esac

        if [ -z "$1" ]; then
            printf "%-71s\t%-9s\n" "$fn" $basesize
        elif [ "$1" = "+" ]; then

            local wal_avail='YES'

            ## XXX: a backup history file might be compressed, too
            first_wal=$(cat "$x" | gunzip -c -f | start_wal_location)

            (test -f "$archivedir/log/$first_wal" || test -f "$archivedir/log/$first_wal.gz") || export wal_avail='NO'
            printf "%-53s\t%s\t%-24s\t%-3s\n" "$fn" $basesize $first_wal $wal_avail
        fi
    done

    ## sum up archive log size
    wallogsize=$(du -sh "$archivedir/log/" | awk '{print $1;}')
    walcount=$(ls -1 "$archivedir/log/" | egrep '^[0-9A-Z]{24}\.?[gz]*$' | wc -l)
    echo $hdrline
    printf "Total size occupied by %d WAL segments in archive: %-9s\n" $walcount $wallogsize
}

# check prerequisites
check_archivedir

case $mode in
    setup)
	check_datadir
        do_setup;;
    currentbackup)
        check_rsync_dep
	check_datadir
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_currentbackup
        ) 284>$LOCK
        ;;
    basebackup)
	check_datadir
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_basebackup
        ) 284>$LOCK
        ;;
    lvmbasebackup)
	check_datadir
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_lvmbasebackup
        ) 284>$LOCK
        ;;
    create-lvmsnapshot)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_create-lvmsnapshot
        ) 284>$LOCK
        ;;
    remove-lvmsnapshot)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_remove-lvmsnapshot
        ) 284>$LOCK
        ;;
    ls)
        ## ls command without any arguments accesses the
        ## filesystem only, thus no lock required
        do_ls
        ;;
    ls+)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_ls '+'
        ) 284>$LOCK
        ;;
    cleanup)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_cleanup "$@"
        ) 284>$LOCK
        ;;
    restore)
	## NOTE: do_restore_basebackup() does its
	##       own sanity checks on $datadir
	(
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_restore_basebackup "$1" "$datadir"	    
	) 284>$LOCK
	;;
    *)
        error "invalid mode";;
esac
