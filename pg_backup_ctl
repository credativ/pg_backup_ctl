#!/bin/sh

set -e
umask 077
# This is required so that sorted directory listings are consistent.
export LC_COLLATE=C

me=$(basename $0)
hdrline=$(printf "%080d"|tr "0" "-")

## configure locking behavior
LOCK=/var/lock/pg_backup_ctl.base.lock
PG_BACKUP_LOCK_TIMEOUT=60

help="\
PostgreSQL transaction log archival backup control program
Supports PostgreSQL 8.3 and above

Usage:
  $me MODE [OPTION...]

Modes:
  setup          prepare server for transaction log archival
  basebackup     perform a base backup
  lvmbasebackup  perform a base backup using LVM snapshot
                 (requires -L, -n and -M)
  currentbackup  backup the current WAL file (run from cron job)
  cleanup        remove old WAL files after new base backup (run from cron job)
  ls[+]          Lists available base backups and their size in the current archive. 
                 When issued with +, the ls command will examine the WAL archive
                 and the minimum WAL segment file, required to use the backup 
                 to perform a full recovery.

Options:
  -A DIR        archival target directory (required)
  -D DIR        database system directory (recommended)
  -h HOSTNAME   server host name
  -L LVM SIZE   determines the buffer size for a LVM snapshot
  -M VOLUME     LVM volume identifier to create the snapshot on
  -m            archive old log files before deleting them
  -n SNAPSHOT   LVM snapshot volume name
  -N LVMDATADIR Taking LVM snapshot is done by mounting
                a LVM snapshot in ARCHIVE/lvm_snapshot. You need
                to specify the PostgreSQL DATADIR relative to
                the mountpoint in ARCHIVE/lvm_snapshot
  -p PORT       server port
  -U USERNAME   user name for database connections
  -z            use gzip to compress archived WAL segments
"

if [ "$1" = "--help" ]; then
    echo "$help"
    exit 0
fi

set -- $(getopt A:D:h:L:M:mn:N:p:U:z "$@")

while :; do
    case $1 in
        -A) archivedir=$2; shift;;
        -D) datadir=$2; shift;;
        -h) export PGHOST=$2; shift;;
	-L) lvm_size=$2; shift;;
	-n) lvm_snap_name=$2; shift;;
	-M) lvm_vol=$2; shift;;
        -m) cleanup_move=yes;;
	-n) lvm_snap_name=$2; shift;;
	-N) lvmdatadir=$2; shift;;
        -p) export PGPORT=$2; shift;;
        -U) export PGUSER=$2; shift;;
        -z) gzip=yes;;
        --) shift; break;;
    esac
    shift
done

export PGDATABASE=postgres

mode=$1; shift || :


error() {
    echo "$me:" "$@" 1>&2
    exit 1
}


current_setting() {
    psql -tA -c "SELECT current_setting('$1');"
}


timestamp() {
    # A detailed timestamp is good to uniquely identify a backup.
    date +'%Y-%m-%dT%H:%M:%S.%N%:z'
}


check_dirs() {
    # Especially when calling currentbackup, specifying a data directory
    # directly is advisable to avoid frequent database connections.
    if [ -z "$datadir" ]; then
        datadir="$(current_setting data_directory)"
    fi

    if [ ! -r "$datadir"/PG_VERSION ]; then
        error "cannot read data directory (permissions?)"
    fi

    if [ -z "$archivedir" ]; then
        error "no archive directory specified"
    fi

    local x

    for x in "$archivedir"/{base,log,current,lvm_snapshot}; do
        if [ ! -d "$x" ]; then
            mkdir -p "$x"
            chown --reference="$datadir" "$x"
        fi
    done
}

check_lvm_params() {

	## check LVM parameters

	if [ -z "$lvm_size" ]; then
		error "no LVM snapshot size (-L) specified" 
	fi
	
	## specified volume exists?
	if [ -z "$lvm_vol" ]; then
		error "no LVM volume specified"
        else
                if ! sudo /sbin/lvdisplay $lvm_vol > /dev/null 2>&1; then
                    error "logical volume \"$lvm_vol\" not found"
                else
		    local RC=$(sudo /sbin/lvdisplay -c $lvm_vol | awk -F ':' '{print $4;}')
		    if [ "$RC" -ne 1 ]; then 
                        error "\"$lvm_vol\" is not a valid LVM volume"
                    fi
                fi
	fi

	if [ -z "$lvm_snap_name" ]; then
		error "no LVM backup name (-n) specified"
	fi

	if [ -z "$lvmdatadir" ]; then
		error "LVM snapshots requires the datadir relative to $archivedir/lvm_snapshot"
	fi

}

do_setup() {
    check_dirs

    if [ $(ls "$datadir"/pg_tblspc | wc -l) -gt 0 ]; then
        error "tablespaces not supported"
    fi

    local cmd
    if [ "$gzip" = yes ]; then
        cmd="test ! -f \\\\'$archivedir/log/%f.gz\\\\' && gzip -c \\\\'%p\\\\' > \\\\'$archivedir/log/%f.gz\\\\'"
    else
        cmd="test ! -f \\\\'$archivedir/log/%f\\\\' && cp \\\\'%p\\\\' \\\\'$archivedir/log/%f\\\\'"
    fi
    local cf=$(current_setting config_file)

    if grep -q archive_command "$cf"; then
        sed -i -e '/archive_command/ c\' -e "archive_command = '$cmd'" "$cf"
    else
        (echo; echo "# automatically added by $me"; echo "archive_command = '$cmd'") >>$cf
    fi

    ## Activate archiving. This requires a server restart if not yet set. Hint the
    ## user, if we changed anything here.
    local archivemode=$(current_setting archive_mode)

    if grep -q archive_mode "$cf"; then
        if [ ! -z "$archivemode" ] && [ "$archivemode" = "off" ]; then
            sed -i -e '/archive_mode/ c\' -e "archive_mode = on" "$cf";
            echo "HINT: activated archive_mode, you need to restart the server to get archiving activated"
        else
            echo "HINT: archive_mode already activated, adjusted archive_command only"
        fi
    else
        (echo; echo "# automatically added by $me"; echo "archive_mode = on") >>$cf        
    fi

    kill -HUP $(head -1 "$datadir/postmaster.pid")
}


do_currentbackup() {
    check_dirs

    local files x y

    # identify unarchived files
    for x in $(ls -r "$datadir"/pg_xlog/ | egrep '^[0-9A-F]{24}$'); do
        if [ ! -f "$datadir"/pg_xlog/archive_status/$x.done ]; then
            files="$files $x"
        fi
    done

    # copy unarchived files
    (cd "$datadir"/pg_xlog/ && rsync $files "$archivedir"/current/)

    # remove previously copied files that are now archived
    for x in $(cd "$archivedir"/current && ls); do
        for y in $files; do
            [ $x = $y ] && break 2
        done
        rm "$archivedir"/current/$x
    done
}


do_basebackup() {
    check_dirs

    local status=0

    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz
    psql -c "SELECT pg_start_backup('$fn');" >/dev/null
    tar --force-local -C "$datadir" -c -z -f "$fn" --anchored --exclude=pg_xlog . || status=$?
    psql -c "SELECT pg_stop_backup();" >/dev/null
    [ $status -eq 0 ] || [ $status -eq 1 ]
}

do_lvmbasebackup() {
    check_dirs
    check_lvm_params

    local status=0

    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz
    psql -c "SELECT pg_start_backup('$fn');" >/dev/null
    sudo lvcreate -s -n "$lvm_snap_name" -L "$lvm_size" "$lvm_vol" || status=$? 
    psql -c "SELECT pg_stop_backup();" >/dev/null
    [ $status -ne 0 ] && echo "LVM snapshot failed with status $status" && return $status

    ## mount the snapshot in the archive directory LVM snaphost mountpoint
    local LVMSNAPSHOTMNT="$(dirname $lvm_vol)/$lvm_snap_name"
    sudo /bin/mount $LVMSNAPSHOTMNT "$archivedir"/lvm_snapshot || error "could not mount snapshot in $archivedir/lvm_snapshot"

    ## do the backup, fall through all errors!
    tar --force-local -C "$archivedir/lvm_snapshot/$lvmdatadir" -c -z -f "$fn" --anchored --exclude=pg_xlog . || status=$?   

    ## unmount the snapshot
    sudo /bin/umount "$archivedir"/lvm_snapshot
    echo "removing LVM snapshot $LVMSNAPSHOTMNT"
    sudo /sbin/lvremove -f -t $LVMSNAPSHOTMNT > /dev/null 2>&1 && sudo /sbin/lvremove -f $LVMSNAPSHOTMNT 1> /dev/null || status=$?
    [ $status -eq 0 ] || [ $status -eq 1 ]

}

start_wal_location() { 
    sed -n -r '/^START WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


stop_wal_location() { 
    sed -n -r '/^STOP WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


do_cleanup() {
    local first_wal last_wal x

    local fn=$(basename "$1")
    case $fn in
        basebackup_*.tar*)
            first_wal=$(gunzip -c -f "$1" | tar -f - -x -O ./backup_label | start_wal_location)
            ;;
        [0-9A-F]*[0-9A-F].[0-9A-F]*[0-9A-F].backup*)
            first_wal=$(gunzip -c -f "$1" | start_wal_location)
            last_wal=$(gunzip -c -f "$1" | stop_wal_location)
            if [ ! -f "$archivedir"/log/$last_wal* ]; then
                error "base backup \"$1\" is not complete; log segment \"$last_wal\" is not archived yet"
            fi
            ;;
        '')
            local last_backup
            for x in $(ls -r "$archivedir"/log/*.backup* | head -1); do
                last_wal=$(gunzip -c -f "$x" | stop_wal_location)
                if [ -f "$archivedir"/log/$last_wal ] || [ -f "$archivedir"/log/$last_wal.gz ] ; then
                    last_backup=$x
                    break
                fi
            done
            if [ -z "$last_backup" ]; then
                error "no complete backup found"
            fi
            first_wal=$(gunzip -c -f "$last_backup" | start_wal_location)
            ;;
        *)
            error "invalid cleanup target specification"
            ;;
    esac

    if [ -f "$archivedir"/log/$first_wal ] || [ -f "$archivedir"/log/$first_wal.gz ]; then
        local old_files=$(ls "$archivedir"/log | sed -n "/$first_wal/q;p")
        (
        cd "$archivedir"/log
        if [ "$cleanup_move" = yes ]; then
            tar --force-local -c -z -f "$archivedir"/base/oldwals-$(timestamp).tar.gz $old_files
        fi
        rm -f $old_files
        )
    fi
}

do_ls() {
    check_dirs
    backups=$(ls -t "$archivedir/base")
    
    if [ -z "$1" ]; then
        printf "%-71s\t%-9s\n" "Basebackup Filename" "Size"
    else
        printf "%-53s\t%s\t%-24s\t%-3s\n" "Basebackup Filename" "Size" "Required WAL" "Available"
    fi

    echo $hdrline

    for x in $backups; do

        basesize=$(du -sh "$archivedir/base/$x" | awk '{print $1;}')

        if [ -z "$1" ]; then
            printf "%-71s\t%-9s\n" "$x" $basesize
        elif [ "$1" = "+" ]; then
            first_wal=$(gunzip -c -f "$archivedir/base/$x" | tar -f - -x --force-local -O ./backup_label | start_wal_location)
            local wal_avail='YES'
            test -f "$archivedir/log/$first_wal" || export wal_avail='NO'
            printf "%-53s\t%s\t%-24s\t%-3s\n" "$x" $basesize $first_wal $wal_avail
        fi
    done

    ## sum up archive log size
    wallogsize=$(du -sh "$archivedir/log" | awk '{print $1;}')
    walcount=$(ls -1 "$archivedir/log/" | egrep '^[0-9A-Z]{24}$' | wc -l)
    echo $hdrline
    printf "Total size occupied by %d WAL segments in archive: %-9s\n" $walcount $wallogsize
}

case $mode in
    setup)
        do_setup;;
    currentbackup)
        ( 
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_currentbackup
        ) 284>$LOCK
        ;;
    basebackup)
        ( 
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_basebackup
        ) 284>$LOCK
        ;;
    lvmbasebackup)
        ( 
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_lvmbasebackup
        ) 284>$LOCK
        ;;
    ls)
        ## ls command without any arguments accesses the 
        ## filesystem only, thus no lock required
        do_ls
        ;;
    ls+)
        ( 
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_ls '+'
        ) 284>$LOCK
        ;;
    cleanup)
        ( 
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_cleanup "$@"
        ) 284>$LOCK
        ;;
    *)
        error "invalid mode";;
esac
