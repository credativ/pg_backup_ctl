#!/bin/sh

set -e
umask 077
# This is required so that sorted directory listings are consistent.
export LC_COLLATE=C

me=$(basename $0)

help="\
PostgreSQL transaction log archival backup control program

Usage:
  $me MODE [OPTION...]

Modes:
  setup          prepare server for transaction log archival
  basebackup     perform a base backup
  currentbackup  backup the current WAL file (run from cron job)
  cleanup        remove old WAL files after new base backup (run from cron job)

Options:
  -A DIR       archival target directory (required)
  -D DIR       database system directory (recommended)
  -h HOSTNAME  server host name
  -m           archive old log files before deleting them
  -p PORT      server port
  -U USERNAME  user name for database connections
  -z           use gzip to compress archived WAL segments
"

if [ "$1" = "--help" ]; then
    echo "$help"
    exit 0
fi


set -- $(getopt A:D:h:mp:U:z "$@")

while :; do
    case $1 in
        -A) archivedir=$2; shift;;
        -D) datadir=$2; shift;;
        -h) export PGHOST=$2; shift;;
        -m) cleanup_move=yes;;
        -p) export PGPORT=$2; shift;;
        -U) export PGUSER=$2; shift;;
        -z) gzip=yes;;
        --) shift; break;;
    esac
    shift
done

export PGDATABASE=postgres

mode=$1; shift || :


error() {
    echo "$me:" "$@" 1>&2
    exit 1
}


current_setting() {
    psql -tA -c "SELECT current_setting('$1');"
}


timestamp() {
    # A detailed timestamp is good to uniquely identify a backup.
    date +'%Y-%m-%dT%H:%M:%S.%N%:z'
}


check_dirs() {
    # Especially when calling currentbackup, specifying a data directory
    # directly is advisable to avoid frequent database connections.
    if [ -z "$datadir" ]; then
        datadir="$(current_setting data_directory)"
    fi

    if [ ! -r "$datadir"/PG_VERSION ]; then
        error "cannot read data directory (permissions?)"
    fi

    if [ -z "$archivedir" ]; then
        error "no archive directory specified"
    fi

    local x

    for x in "$archivedir"/{base,log,current}; do
        if [ ! -d "$x" ]; then
            mkdir -p "$x"
            chown --reference="$datadir" "$x"
        fi
    done
}


do_setup() {
    check_dirs

    if [ $(ls "$datadir"/pg_tblspc | wc -l) -gt 0 ]; then
        error "tablespaces not supported"
    fi

    local cmd
    if [ "$gzip" = yes ]; then
        cmd="test ! -f \\\\'$archivedir/log/%f.gz\\\\' && gzip -c \\\\'%p\\\\' > \\\\'$archivedir/log/%f.gz\\\\'"
    else
        cmd="test ! -f \\\\'$archivedir/log/%f\\\\' && cp \\\\'%p\\\\' \\\\'$archivedir/log/%f\\\\'"
    fi
    local cf=$(current_setting config_file)

    if grep -q archive_command "$cf"; then
        sed -i -e '/archive_command/ c\' -e "archive_command = '$cmd'" "$cf"
    else
        (echo; echo "# automatically added by $me"; echo "archive_command = '$cmd'") >>$cf
    fi

    kill -HUP $(head -1 "$datadir/postmaster.pid")
}


do_currentbackup() {
    check_dirs

    local files x y

    # identify unarchived files
    for x in $(ls -r "$datadir"/pg_xlog/ | egrep '^[0-9A-F]{24}$'); do
        if [ ! -f "$datadir"/pg_xlog/archive_status/$x.done ]; then
            files="$files $x"
        fi
    done

    # copy unarchived files
    (cd "$datadir"/pg_xlog/ && rsync $files "$archivedir"/current/)

    # remove previously copied files that are now archived
    for x in $(cd "$archivedir"/current && ls); do
        for y in $files; do
            [ $x = $y ] && break 2
        done
        rm "$archivedir"/current/$x
    done
}


do_basebackup() {
    check_dirs

    local status=0

    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz
    psql -c "SELECT pg_start_backup('$fn');" >/dev/null
    tar --force-local -C "$datadir" -c -z -f "$fn" --anchored --exclude=pg_xlog . || status=$?
    psql -c "SELECT pg_stop_backup();" >/dev/null
    [ $status -eq 0 ] || [ $status -eq 1 ]
}


start_wal_location() { 
    sed -n -r '/^START WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


stop_wal_location() { 
    sed -n -r '/^STOP WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


do_cleanup() {
    local first_wal last_wal x

    local fn=$(basename "$1")
    case $fn in
        basebackup_*.tar*)
            first_wal=$(gunzip -c -f "$1" | tar -f - -x -O ./backup_label | start_wal_location)
            ;;
        [0-9A-F]*[0-9A-F].[0-9A-F]*[0-9A-F].backup*)
            first_wal=$(gunzip -c -f "$1" | start_wal_location)
            last_wal=$(gunzip -c -f "$1" | stop_wal_location)
            if [ ! -f "$archivedir"/log/$last_wal* ]; then
                error "base backup \"$1\" is not complete; log segment \"$last_wal\" is not archived yet"
            fi
            ;;
        '')
            local last_backup
            for x in $(ls -r "$archivedir"/log/*.backup* | head -1); do
                last_wal=$(gunzip -c -f "$x" | stop_wal_location)
                if [ -f "$archivedir"/log/$last_wal ] || [ -f "$archivedir"/log/$last_wal.gz ] ; then
                    last_backup=$x
                    break
                fi
            done
            if [ -z "$last_backup" ]; then
                error "no complete backup found"
            fi
            first_wal=$(gunzip -c -f "$last_backup" | start_wal_location)
            ;;
        *)
            error "invalid cleanup target specification"
            ;;
    esac

    if [ -f "$archivedir"/log/$first_wal ] || [ -f "$archivedir"/log/$first_wal.gz ]; then
        local old_files=$(ls "$archivedir"/log | sed -n "/$first_wal/q;p")
        (
        cd "$archivedir"/log
        if [ "$cleanup_move" = yes ]; then
            tar --force-local -c -z -f "$archivedir"/base/oldwals-$(timestamp).tar.gz $old_files
        fi
        rm -f $old_files
        )
    fi
}


case $mode in
    setup)
        do_setup;;
    currentbackup)
        do_currentbackup;;
    basebackup)
        do_basebackup;;
    cleanup)
        do_cleanup "$@";;
    *)
        error "invalid mode";;
esac
