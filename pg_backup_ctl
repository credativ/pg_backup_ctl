#!/bin/bash

# Copyright (c) 2007 Peter Eisentraut <peter.eisentraut@credativ.de>
# Copyright (c) 2007-2012 Bernd Helmle <bernd.helmle@credativ.de>
# Copyright (c) 2011-2012 Arnd Hannemann <arnd.hannemann@credativ.de>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE

##
## pg_backup_ctl - PostgreSQL transaction log archival backup control program
##
## Version: @@VERSION@@

set -e
umask 077
# This is required so that sorted directory listings are consistent.
export LC_COLLATE=C

me=$(basename $0)
hdrline=$(printf "%080d"|tr "0" "-")

## Specify lock file location and locking timeout. Note
## that LOCK is overriden by check_dirs() to be in $archivedir instead,
## this is just a fallback setting (which, in fact, isn't currently used).
LOCK=/var/lock/pg_backup_ctl.base.lock
PG_BACKUP_LOCK_TIMEOUT=60

help="\
PostgreSQL transaction log archival backup control program
Supports PostgreSQL 8.3 and above

Usage:
  $me MODE [OPTION...]

Modes:
  setup
                 prepare server for transaction log archival
  basebackup
                 perform a base backup
  lvmbasebackup
                 perform a base backup using LVM snapshot
                 (requires -L, -n and -M)
  create-lvmsnapshot
                 create a LVM snapshot for an external backup command
                 (requires -L, -n and -M)
  remove-lvmsnapshot
                 remove a LVM snapshot created with the create-lvmsnapshot
                 command.
  currentbackup
                 backup the current WAL file (run from cron job)
  cleanup [ FILENAME | XLOG | +[1-9]* ]
                 remove old WAL files after new base backup (run from cron job)

                 It is possible to specify the base backup filename FILENAME,
                 which WAL files should be kept at least or the WAL file XLOG.
                 If a positiv number greater than zero is specified, the cleanup
                 command will treat it as its retention policy and keep at
                 least this number of base backup files. Please note that the
                 latter form of the cleanup command will delete all outdated
                 base backups as well whereas the two forms of cleanup invoked
                 with filenames will delete the WAL files only.

                 If no argument is specified, cleanup will remove all WAL
                 files except those which are required by the latest base
                 backup.
  ls[+]
                 Lists available base backups and their size in the current archive.
                 When issued with +, the ls command will examine the WAL archive
                 and the minimum WAL segment file, required to use the backup
                 to perform a full recovery.

Options:
  -A DIR        archival target directory (required)
  -D DIR        database system directory (recommended)
  -h HOSTNAME   server host name
  -L LVM SIZE   determines the buffer size for a LVM snapshot
  -M VOLUME     LVM volume identifier to create the snapshot on
  -m            archive old log files before deleting them
  -n SNAPSHOT   LVM snapshot volume name
  -N LVMDATADIR Taking LVM snapshot is done by mounting
                a LVM snapshot in ARCHIVE/lvm_snapshot. You need
                to specify the PostgreSQL DATADIR relative to
                the mountpoint in ARCHIVE/lvm_snapshot
  -o MOUNTOPTS  additional options passed to snapshot mount if used
                with LVM snapshots
  -p PORT       server port
  -U USERNAME   user name for database connections
  -z            use gzip to compress archived WAL segments
"

if [ "$1" = "--help" ]; then
    echo "$help"
    exit 0
fi

set -- $(getopt A:D:h:L:M:mn:N:o:p:U:z "$@")

while :; do
    case $1 in
        -A) archivedir=$2; shift;;
        -D) datadir=$2; shift;;
        -h) export PGHOST=$2; shift;;
	-L) lvm_size=$2; shift;;
	-n) lvm_snap_name=$2; shift;;
	-M) lvm_vol=$2; shift;;
        -m) cleanup_move=yes;;
	-n) lvm_snap_name=$2; shift;;
	-N) lvmdatadir=$2; shift;;
        -o) mountopts=$2; shift;;
        -p) export PGPORT=$2; shift;;
        -U) export PGUSER=$2; shift;;
        -z) gzip=yes;;
        --) shift; break;;
    esac
    shift
done

export PGDATABASE=postgres

mode=$1; shift || :


error() {
    echo "$me:" "$@" 1>&2
    exit 1
}


current_setting() {
    psql -tA -c "SELECT current_setting('$1');"
}

timestamp() {
    # A detailed timestamp is good to uniquely identify a backup.
    date +'%Y-%m-%dT%H:%M'
}

check_deps() {
	# check if needed programs are there
	if ! command -v rsync >/dev/null; then
		error "cannot find rsync command"
	fi;
}

##
## Returns the PostgreSQL major version of the specified PGDATA directory
## as an integer. That is, the first two digits are concatenated to a unified
## number so it can be compared arithmetically (e.g. 9.0.4 will be returned
## as 90).
##
## Caller should make sure PGDATA really exists
##
get_pg_major_version() {

    local PGMAJOR=$(cat "$datadir"/PG_VERSION | awk -F'.' '{print $1$2;}')
    echo $PGMAJOR

}

check_dirs() {
    # Especially when calling currentbackup, specifying a data directory
    # directly is advisable to avoid frequent database connections.
    if [ -z "$datadir" ]; then
        datadir="$(current_setting data_directory)"
    fi

    if [ ! -r "$datadir"/PG_VERSION ]; then
        error "cannot read data directory (permissions?)"
    fi

    if [ -z "$archivedir" ]; then
        error "no archive directory specified"
    fi

    local x

    for x in "$archivedir"/{base,log,current,lvm_snapshot}; do
        if [ ! -d "$x" ]; then
            mkdir -p "$x"
        fi
    done

    ## Force LOCK file to be in $archivedir. This fixes an issue on
    ## some Linux systems, where /var/lock/ isn't writeable by daemons.
    ## $archivedir must be writable by the postgres user anyways, so we silently
    ## assume that we can use it for the lock file, too.
    LOCK="$archivedir/$(basename $LOCK)"
}

check_lvm_params() {

	## check LVM parameters

	if [ -z "$lvm_size" ]; then
		error "no LVM snapshot size (-L) specified"
	fi

	## specified volume exists?
	if [ -z "$lvm_vol" ]; then
		error "no LVM volume specified"
        else
                if ! sudo /sbin/lvdisplay $lvm_vol > /dev/null 2>&1; then
                    error "logical volume \"$lvm_vol\" not found"
                else
		    local RC=$(sudo /sbin/lvdisplay -c $lvm_vol | awk -F ':' '{print $4;}')
		    if [ "$RC" -ne 1 ]; then
                        error "\"$lvm_vol\" is not a valid LVM volume"
                    fi
                fi
	fi

	if [ -z "$lvm_snap_name" ]; then
		error "no LVM backup name (-n) specified"
	fi

	if [ -z "$lvmdatadir" ]; then
		error "LVM snapshots requires the datadir relative to $archivedir/lvm_snapshot"
	fi

        if [ ! -z "$mountopts" ]; then
            mountopts="-o $mountopts"
        fi
}

do_setup() {

    if [ $(ls "$datadir"/pg_tblspc | wc -l) -gt 0 ]; then
        error "tablespaces not supported"
    fi

    local cmd
    if [ "$gzip" = yes ]; then
        cmd="test ! -f \\\\'$archivedir/log/%f.gz\\\\' && gzip -c \\\\'%p\\\\' > \\\\'$archivedir/log/%f.gz\\\\'"
    else
        cmd="test ! -f \\\\'$archivedir/log/%f\\\\' && cp \\\\'%p\\\\' \\\\'$archivedir/log/%f\\\\'"
    fi
    local cf=$(current_setting config_file)

    if grep -q archive_command "$cf"; then
        sed -i -e "/archive_command/ c\\
                   archive_command = '$cmd'
                   a\\" "$cf"
    else
        (echo; echo "# automatically added by $me"; echo "archive_command = '$cmd'") >>$cf
    fi

    ## Activate archiving. This requires a server restart if not yet set. Hint the
    ## user, if we changed anything here.
    local archivemode=$(current_setting archive_mode)

    if grep -q archive_mode "$cf"; then
        if [ ! -z "$archivemode" ] && [ "$archivemode" = "off" ]; then
            sed -i -e '/archive_mode/ c\
                       archive_mode = on
                       a\' "$cf"
            echo "HINT: activated archive_mode, you need to restart the server to get archiving activated"
        else
            echo "HINT: archive_mode already activated, adjusted archive_command only"
        fi
    else
        (echo; echo "# automatically added by $me"; echo "archive_mode = on") >>$cf
    fi

    ## Starting with PostgreSQL 9.0, we define different wal levels to adjust the traffic into
    ## the transaction log. For archiving, we need at least wal_level = archive to be set, otherwise
    ## PostgreSQL will refuse to start.

    if [ $(get_pg_major_version) -ge 90 ]; then
        local wallevel=$(current_setting wal_level)

        if grep -q wal_level "$cf"; then
            if [ ! -z "$wallevel" ] && [ "$wallevel" != "archive" ] && [ "$wallevel" != "hot_standby" ]; then
                sed -i -e '/wal_level/ c\
                           wal_level = archive
                           a\' "$cf"
                echo "HINT: set wal_level to 'archive', you need to restart the server to get this setting into effect"
            else
                echo "HINT: wal_level already set to 'archive'"
            fi
        else
            (echo; echo "# automatically added by $me"; echo "wal_level = archive") >>$cf
        fi
    fi

    kill -HUP $(head -1 "$datadir/postmaster.pid")
}


do_currentbackup() {

    local files x y

    # identify unarchived files
    for x in $(ls -r "$datadir"/pg_xlog/ | egrep '^[0-9A-F]{24}$'); do
        if [ ! -f "$datadir"/pg_xlog/archive_status/$x.done ]; then
            files="$files $x"
        fi
    done

    # copy unarchived files
    (cd "$datadir"/pg_xlog/ && rsync $files "$archivedir"/current/)

    # remove previously copied files that are now archived
    for x in $(cd "$archivedir"/current && ls); do
        for y in $files; do
            [ $x = $y ] && break 2
        done
        rm "$archivedir"/current/$x
    done
}


do_basebackup() {

    local status=0

    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz
    psql -c "SELECT pg_start_backup('$fn');" >/dev/null
    tar --force-local -C "$datadir" -c -z -f "$fn" --exclude=pg_xlog . || status=$?
    psql -c "SELECT pg_stop_backup();" >/dev/null
    [ $status -eq 0 ] || [ $status -eq 1 ]
}

##
## Create a LVM snapshot, pass $2 as a backup label
## to pg_start_backup() if required, overriding the default
## label "LVM SNAPSHOT YYYY-MM-DDTHH24:MI"
##
_create_snapshot_LVM() {

    local status=0
    local fn="$1"
    local label

    if [ ! -z "$2" ]; then
        label="$fn"
    else
        ##
        ## XXX: We obtain a separate timestamp for labeling the LVM snapshot.
        ##      Do this only in case no backup_label was specified (which,
        ##      effectively would have generated the label and basebackup
        ##      filename already).
        ##
        label="LVM SNAPSHOT $(timestamp)"
    fi

    psql -c "SELECT pg_start_backup('$label');" >/dev/null
    sudo lvcreate -s -n "$lvm_snap_name" -L "$lvm_size" "$lvm_vol" || status=$?

    psql -c "SELECT pg_stop_backup();" >/dev/null
    [ $status -ne 0 ] && echo "LVM snapshot failed with status $status" && return $status

    ## mount the snapshot in the archive directory LVM snaphost mountpoint
    local LVMSNAPSHOTMNT="$(dirname $lvm_vol)/$lvm_snap_name"
    sudo /bin/mount $mountopts $LVMSNAPSHOTMNT "$archivedir"/lvm_snapshot || error "could not mount snapshot in $archivedir/lvm_snapshot"

}

##
## Remove a LVM snapshot previously created with _create_snapshot_LVM
##
_remove_snapshot_LVM() {

    local status=0
    local LVMSNAPSHOTMNT="$(dirname $lvm_vol)/$lvm_snap_name"

    ## unmount the snapshot
    sudo /bin/umount "$archivedir"/lvm_snapshot
    echo "removing LVM snapshot $LVMSNAPSHOTMNT"
    sudo /sbin/lvremove -f -t $LVMSNAPSHOTMNT > /dev/null 2>&1 && sudo /sbin/lvremove -f $LVMSNAPSHOTMNT 1> /dev/null || status=$?

    return $status
}

##
## Create a LVM snapshot and perform a basebackup via tar.
##
## This calls _create_snapshot_LVM() internally, which does
## the legwork of creating the necessary LVM snapshot and
## prepares the mount.
##
## Please note that do_create-lvmsnapshot never performs a real basebackup,
## instead it creates an archive file with just the backup_label included. It
## is up to an external backup software to do the actual base backup.
##
do_create-lvmsnapshot() {
    check_lvm_params

    local status=0
    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz

    ## do the backup, fall through all errors!
    if _create_snapshot_LVM "$fn"; then
        tar --force-local -C "$archivedir/lvm_snapshot/$lvmdatadir/" -c -z -f "$fn" ./backup_label || status=$?
    fi

    [ $status -eq 0 ] || [ $status -eq 1 ]
}

##
## Remove a LVM snapshot previously created via _create_snapshot_LVM().
##
do_remove-lvmsnapshot() {
    local status=0

    _remove_snapshot_LVM || status=$?

    [ $status -eq 0 ] || [ $status -eq 1 ]
}

##
## Creates a full basebackup from a LVM snapshot.
##
do_lvmbasebackup() {
    check_lvm_params

    local status=0

    local fn="$archivedir"/base/basebackup_$(timestamp).tar.gz
    _create_snapshot_LVM "$fn" "$fn"

    ## do the backup, fall through all errors!
    tar --force-local -C "$archivedir/lvm_snapshot/$lvmdatadir" -c -z -f "$fn" --exclude=pg_xlog . || status=$?

    ## unmount the snapshot
    _remove_snapshot_LVM || status=$?

    [ $status -eq 0 ] || [ $status -eq 1 ]
}

start_wal_location() {
    sed -n -r '/^START WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


stop_wal_location() {
    sed -n -r '/^STOP WAL LOCATION:/s/^.*file ([0-9A-F]{24}).*$/\1/p'
}


do_cleanup() {
    local first_wal last_wal x

    local fn=$(basename "$1")
    case $fn in
        basebackup_*.tar*)
            first_wal=$(gunzip -c -f "$1" | tar -f - -x -O ./backup_label | start_wal_location)
            ;;
        [0-9A-F]*[0-9A-F].[0-9A-F]*[0-9A-F].backup*)
            first_wal=$(gunzip -c -f "$1" | start_wal_location)
            last_wal=$(gunzip -c -f "$1" | stop_wal_location)
            if [ ! -f "$archivedir"/log/$last_wal* ]; then
                error "base backup \"$1\" is not complete; log segment \"$last_wal\" is not archived yet"
            fi
            ;;
        '')
            local last_backup
            for x in $(ls -r "$archivedir"/log/*.backup* | head -1); do
                last_wal=$(gunzip -c -f "$x" | stop_wal_location)
                if [ -f "$archivedir"/log/$last_wal ] || [ -f "$archivedir"/log/$last_wal.gz ] ; then
                    last_backup=$x
                    break
                fi
            done
            if [ -z "$last_backup" ]; then
                error "no complete backup found"
            fi
            first_wal=$(gunzip -c -f "$last_backup" | start_wal_location)
            ;;
	+[1-9]*)
	    local retention_policy=$1
	    local base_backups=$(ls -tr "$archivedir"/base/basebackup_*.tar*)
	    local num_backups=$(echo "$base_backups" | wc -l)

	    if [ $num_backups -le $retention_policy ]; then
		echo "no base backups to delete found"
		return 1
	    else
		local candidates
		local newest_candidate

		candidates=$(echo "$base_backups" | head -n $(($num_backups - $retention_policy)))
		oldest_keep=$(echo "$base_backups" | head -n $(($num_backups - $retention_policy + 1)) | tail -n1)
		newest_candidate=$(echo "$candidates" | tail -n1)

		## This recurses into cleanup and removes all WAL files
		## belonging to the list of candidates. Those aren't required
		## anymore, since we are going to delete base backup candidates
		## afterwards.
		## NOTE:
		##
		## We need to specify the oldest base backup to *keep*, since
		## do_cleanup() will keep all WAL files belonging to the specified
		## base backup.
                ##
                ## XXX: Currently we are performing the cleanup based on selecting
                ##      the base backup files from $archivedir/base. In the
                ##      future, we might change this code to select the base
                ##      backups according to the backup history files found there.
		do_cleanup $oldest_keep

		for i in $candidates; do
		    rm "$i"
		done
	    fi

	    ## exit immediately after cleaning base backups. We *must* return
	    ## to the caller, otherwise do_cleanup() will proceed and delete all WAL
	    ## files older than the current base backup.
	    return 0
	    ;;
        *)
            error "invalid cleanup target specification"
            ;;
    esac

    if [ -f "$archivedir"/log/$first_wal ] || [ -f "$archivedir"/log/$first_wal.gz ]; then
        local old_files=$(ls "$archivedir"/log | sed -n "/$first_wal/q;p")
        (
        cd "$archivedir"/log
        if [ "$cleanup_move" = yes ]; then
            tar --force-local -c -z -f "$archivedir"/base/oldwals-$(timestamp).tar.gz $old_files
        fi
        rm -f $old_files
        )
    fi
}

backup_label() {
    sed -n -e '/^LABEL:/s/^LABEL://;s/^\s//p'
}

do_ls() {

    local backups basesize wallogsize walcount

    backups=$(ls -t $archivedir/log/[0-9A-F]*[0-9A-F].[0-9A-F]*[0-9A-F].backup* 2> /dev/null || return 0)

    if [ -z "$1" ]; then
        printf "%-71s\t%-9s\n" "Basebackup Filename" "Size"
    else
        printf "%-53s\t%s\t%-24s\t%-3s\n" "Basebackup Filename" "Size" "Required WAL" "Available"
    fi

    echo $hdrline

    for x in $backups; do

        local fn=$(basename "$(cat "$x" | gunzip -f -c | backup_label)")

        case $fn in

            basebackup_*.tar.gz)
                fn="$(basename $fn)"
                basesize=$(du -sh "$archivedir/base/$fn" | awk '{print $1;}')
                ;;
            *SNAPSHOT*)
                basesize=0
                ;;
            *)
                echo "\"$fn\" is not an expected basebackup filename"
                ;;

        esac

        if [ -z "$1" ]; then
            printf "%-71s\t%-9s\n" "$fn" $basesize
        elif [ "$1" = "+" ]; then

            local wal_avail='YES'

            ## XXX: a backup history file might be compressed, too
            first_wal=$(cat "$x" | gunzip -c -f | start_wal_location)

            (test -f "$archivedir/log/$first_wal" || test -f "$archivedir/log/$first_wal.gz") || export wal_avail='NO'
            printf "%-53s\t%s\t%-24s\t%-3s\n" "$fn" $basesize $first_wal $wal_avail
        fi
    done

    ## sum up archive log size
    wallogsize=$(du -sh "$archivedir/log/" | awk '{print $1;}')
    walcount=$(ls -1 "$archivedir/log/" | egrep '^[0-9A-Z]{24}\.?[gz]*$' | wc -l)
    echo $hdrline
    printf "Total size occupied by %d WAL segments in archive: %-9s\n" $walcount $wallogsize
}

# check prerequisites
check_dirs
check_deps

case $mode in
    setup)
        do_setup;;
    currentbackup)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_currentbackup
        ) 284>$LOCK
        ;;
    basebackup)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_basebackup
        ) 284>$LOCK
        ;;
    lvmbasebackup)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_lvmbasebackup
        ) 284>$LOCK
        ;;
    create-lvmsnapshot)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_create-lvmsnapshot
        ) 284>$LOCK
        ;;
    remove-lvmsnapshot)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
	    do_remove-lvmsnapshot
        ) 284>$LOCK
        ;;
    ls)
        ## ls command without any arguments accesses the
        ## filesystem only, thus no lock required
        do_ls
        ;;
    ls+)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_ls '+'
        ) 284>$LOCK
        ;;
    cleanup)
        (
            flock -x -w $PG_BACKUP_LOCK_TIMEOUT 284
            do_cleanup "$@"
        ) 284>$LOCK
        ;;
    *)
        error "invalid mode";;
esac
